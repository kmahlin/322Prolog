%
% % need to check stack on each rotation. blah
%
% % use up rotation list
% % return the rotated maze
% % Checks, after each rotation/move if players are stacked
% processRotationListPart04(Maze,[Hr|Tr], R):-
%   % do one rotation
%   processRotation(Maze,Hr,ProcMaze),
% 	% Check if players are stacked
% 	not(stackExists(Maze)),
%   % check if goal still exists
%   goalExists(Maze),
%   % if it does, process the rest of the list
%   processRotationList(ProcMaze,Tr, R),
%   !.
%
% %Goal no longer exists, we out.
% processRotationListPart04(Maze,_, Maze):- !.




  % Move all players in a list of lists
  % movePlayers([],[]).
  % movePlayers([Row|Rows],R):-
  %   movePlayerInRow(Row,NewR),
  %   List = [NewR],
  %   movePlayers(Rows,NewRs),
  %   append(List,NewRs,R),
  %   !.
  % movePlayers(R,R).




% processBFSLists(_,[],_).
% processBFSLists(Maze,[Rlist|Rlists],R):-
%   solvable(Maze,Rlist),
%   List = [Rlist],
%   processBFSLists(Maze,Rlists,NewLists),
%   append(List,NewLists,R),
%   !.
  % processBFSLists(_,[Rlist|Rlists],Rlists).
% processBFSLists(_,[Rlist|Rlists],Rlists).

% processBFSLists(_,[],[]).
% processBFSLists(Maze,[Rlist|Rlists],R):-
%   % solveable?
%   solvable(Maze,Rlist),
%   %Process rest of list
%   processBFSLists(Maze,Rlists,R2),
%   append([Rlist],[R2],R).
% processBFSLists(Maze,[_|Rlists],R):-
%   processBFSLists(Maze,Rlists,R).

% does too many nested lists
% processBFSLists(_,[],[]).
% processBFSLists(Maze,[Rlist|Rlists],R):-
%   % solveable?
%   not(solvable(Maze,Rlist)),
%   %Process rest of list
%   processBFSLists(Maze,Rlists,R),!.
%
% processBFSLists(Maze,[Rlist|Rlists],R):-
%   processBFSLists(Maze,Rlists,R2),
%   append([Rlist],[R2],R).








%Not broken, just storing here

% % bfSearch(From,To,Path).  <- use this to call it
% % Searches for a list of possible rotations
% bfSearch(From,From,[From]).
% bfSearch(From,To,[From|Result]):-
%   length(Result,ResultLength),
%   % writeln(ResultLength),
%   edge(From,Anything),
%   %  write([From|Result]),
%   bfSearch(Anything,To,Result).











countPlayersInMaze([],_):- !.
countPlayersInMaze([Row|Rows],R):-
  countPlayersInRow(Row,R2),
  countPlayersInMaze(Rows,R3),
  R is R2.



// flatten isn't broken, I'm just using builtin flatten for now

  flatten2(List, FlatList) :-
  	flatten2(List, [], FlatList).

  flatten2(Var, T, [Var|T]) :-
  	var(Var), !.
  flatten2([], T, T) :- !.
  flatten2([H|T], TailList, List) :- !,
  	flatten2(H, FlatTail, List),
  	flatten2(T, TailList, FlatTail).

  flatten2(NonList, T, [NonList|T]).




  doRotation(Move,Maze,R):-
    (Move == c,
    rotateClockWise(Maze,R));

    (Move == cc,
    rotateCounterClockWise(Maze,R));

    (Move == 180,
    rotateOneEighty(Maze,R));

    doRotation(Move,Maze,R).



    movePlayer([],_).
    %Move player
    movePlayer([HE|TA],Return):-
      not(player(HE)),
      movePlayer(TA,Return).

    movePlayer([HE,MI|TA],Return):-
      forward(MI),
      movePlayer([MI,HE|TA],Return).



% never worked, used bubble sort instead.
movePlayer([],_):- !.
movePlayer([He|Ta],Result):-
  not(He is 1),
  movePlayer(Ta,Result),
  !.
movePlayer([He|Ta],Result):-
    swap([He|Ta],R1),
    movePlayer(R1,Result),
    !.

swap([],[]).
swap([He,Mi|Ta],[Mi,He|Ta]):- !.
