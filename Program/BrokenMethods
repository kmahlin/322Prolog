



%Not broken, just storing here

% % bfSearch(From,To,Path).  <- use this to call it
% % Searches for a list of possible rotations
% bfSearch(From,From,[From]).
% bfSearch(From,To,[From|Result]):-
%   length(Result,ResultLength),
%   % writeln(ResultLength),
%   edge(From,Anything),
%   %  write([From|Result]),
%   bfSearch(Anything,To,Result).











countPlayersInMaze([],_):- !.
countPlayersInMaze([Row|Rows],R):-
  countPlayersInRow(Row,R2),
  countPlayersInMaze(Rows,R3),
  R is R2.



// flatten isn't broken, I'm just using builtin flatten for now

  flatten2(List, FlatList) :-
  	flatten2(List, [], FlatList).

  flatten2(Var, T, [Var|T]) :-
  	var(Var), !.
  flatten2([], T, T) :- !.
  flatten2([H|T], TailList, List) :- !,
  	flatten2(H, FlatTail, List),
  	flatten2(T, TailList, FlatTail).

  flatten2(NonList, T, [NonList|T]).




  doRotation(Move,Maze,R):-
    (Move == c,
    rotateClockWise(Maze,R));

    (Move == cc,
    rotateCounterClockWise(Maze,R));

    (Move == 180,
    rotateOneEighty(Maze,R));

    doRotation(Move,Maze,R).



    movePlayer([],_).
    %Move player
    movePlayer([HE|TA],Return):-
      not(player(HE)),
      movePlayer(TA,Return).

    movePlayer([HE,MI|TA],Return):-
      forward(MI),
      movePlayer([MI,HE|TA],Return).



% never worked, used bubble sort instead.
movePlayer([],_):- !.
movePlayer([He|Ta],Result):-
  not(He is 1),
  movePlayer(Ta,Result),
  !.
movePlayer([He|Ta],Result):-
    swap([He|Ta],R1),
    movePlayer(R1,Result),
    !.

swap([],[]).
swap([He,Mi|Ta],[Mi,He|Ta]):- !.
